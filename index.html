<html>
<head>
    <title>Leaflet Realtime</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css" />
    <link rel="stylesheet" href="site.css" />
    <style>
        #map {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
        }
    </style>
</head>
<body>
    <span id="forkongithub">
        <a href="https://github.com/perliedman/leaflet-realtime/">Fork me on GitHub</a>
    </span>
    <div id="map"></div>

    <script src="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet-src.js"></script>
    
    
    
    <script>
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.L || (g.L = {})).Realtime = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

L.Realtime = L.Layer.extend({
    options: {
        start: true,
        interval: 60 * 1000,
        getFeatureId: function(f) {
            return f.properties.id;
        },
        updateFeature: function(feature, oldLayer) {
            if (!oldLayer) { return; }

            var type = feature.geometry && feature.geometry.type
            var coordinates = feature.geometry && feature.geometry.coordinates
            switch (type) {
                case 'Point':
                    oldLayer.setLatLng(L.GeoJSON.coordsToLatLng(coordinates));
                    break;
                case 'LineString':
                case 'MultiLineString':
                    oldLayer.setLatLngs(L.GeoJSON.coordsToLatLngs(coordinates, type === 'LineString' ? 0 : 1));
                    break;
                case 'Polygon':
                case 'MultiPolygon':
                    oldLayer.setLatLngs(L.GeoJSON.coordsToLatLngs(coordinates, type === 'Polygon' ? 1 : 2));
                    break;
                default:
                    return null;
            }
            return oldLayer;
          },
        logErrors: true,
        cache: false,
        removeMissing: true,
        onlyRunWhenAdded: false
    },

    initialize: function(src, options) {
        L.setOptions(this, options);
        this._container = options.container || L.geoJson(null, options);

        if (typeof(src) === 'function') {
            this._src = src;
        } else {
            this._fetchOptions = src && src.url ? src : {url: src};
            this._src = L.bind(this._defaultSource, this);
        }

        this._features = {};
        this._featureLayers = {};
        this._requestCount = 0;

        if (this.options.start && !this.options.onlyRunWhenAdded) {
            this.start();
        }
    },

    start: function() {
        if (!this._timer) {
            this._timer = setInterval(L.bind(this.update, this),
                this.options.interval);
            this.update();
        }

        return this;
    },

    stop: function() {
        if (this._timer) {
            clearTimeout(this._timer);
            delete this._timer;
        }

        return this;
    },

    isRunning: function() {
        return this._timer;
    },
    
    setUrl: function (url) {
        if (this._fetchOptions) {
            this._fetchOptions.url = url;
            this.update();
        } else {
            throw new Error('Custom sources does not support setting URL.');
        }
    },    

    update: function(geojson) {
        var requestCount = ++this._requestCount,
            checkRequestCount = L.bind(function(cb) {
                return L.bind(function() {
                    if (requestCount === this._requestCount) {
                        return cb.apply(this, arguments);
                    }
                }, this);
            }, this),
            responseHandler,
            errorHandler;

        if (geojson) {
            this._onNewData(false, geojson);
        } else {
            responseHandler = L.bind(function(data) { this._onNewData(this.options.removeMissing, data); }, this);
            errorHandler = L.bind(this._onError, this);

            this._src(checkRequestCount(responseHandler), checkRequestCount(errorHandler));
        }

        return this;
    },

    remove: function(geojson) {
        var features = L.Util.isArray(geojson) ? geojson : geojson.features ? geojson.features : [geojson],
            exit = {},
            i,
            len,
            fId;

        for (i = 0, len = features.length; i < len; i++) {
            fId = this.options.getFeatureId(features[i]);
            this._container.removeLayer(this._featureLayers[fId]);
            exit[fId] = this._features[fId];
            delete this._features[fId];
            delete this._featureLayers[fId];
        }

        this.fire('update', {
            features: this._features,
            enter: {},
            update: {},
            exit: exit
        });

        return this;
    },

    getLayer: function(featureId) {
        return this._featureLayers[featureId];
    },

    getFeature: function(featureId) {
        return this._features[featureId];
    },

    getBounds: function() {
        var container = this._container;
        if (container.getBounds) {
            return container.getBounds();
        }

        throw new Error('Container has no getBounds method');
    },

    onAdd: function(map) {
        map.addLayer(this._container);
        if (this.options.start) {
            this.start();
        }
    },

    onRemove: function(map) {
        if (this.options.onlyRunWhenAdded) {
            this.stop();
        }
        
        map.removeLayer(this._container);
    },

    _onNewData: function(removeMissing, geojson) {
        var layersToRemove = [],
            enter = {},
            update = {},
            exit = {},
            seenFeatures = {},
            i, len, feature;

        var handleData = L.bind(function(geojson) {
            var features = L.Util.isArray(geojson) ? geojson : geojson.features;
            if (features) {
                for (i = 0, len = features.length; i < len; i++) {
                    // only add this if geometry or geometries are set and not null
                    feature = features[i];
                    if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                        handleData(feature);
                    }
                }
                return;
            }

            var container = this._container;
            var options = this.options;

            if (options.filter && !options.filter(geojson)) { return; }

            var f = L.GeoJSON.asFeature(geojson);
            var fId = options.getFeatureId(f);
            var oldLayer = this._featureLayers[fId];

            var layer = this.options.updateFeature(f, oldLayer);
            if (!layer) {
                layer = L.GeoJSON.geometryToLayer(geojson, options);
                if (!layer) {
                    return;
                }
                layer.defaultOptions = layer.options;
                layer.feature = f;

                if (options.onEachFeature) {
                    options.onEachFeature(geojson, layer);
                }

                if (options.style && layer.setStyle) {
                    layer.setStyle(options.style(geojson));
                }

            }

            layer.feature = f;
            if (container.resetStyle) {
                container.resetStyle(layer);
            }

            if (oldLayer) {
                update[fId] = geojson;
                if (oldLayer != layer) {
                    layersToRemove.push(oldLayer);
                    container.addLayer(layer);
                }
            } else {
                enter[fId] = geojson;
                container.addLayer(layer);
            }

            this._featureLayers[fId] = layer;
            this._features[fId] = seenFeatures[fId] = f;
        }, this);

        handleData(geojson);

        if (removeMissing) {
            exit = this._removeUnknown(seenFeatures);
        }
        for (i = 0; i < layersToRemove.length; i++) {
            this._container.removeLayer(layersToRemove[i]);
        }

        this.fire('update', {
            features: this._features,
            enter: enter,
            update: update,
            exit: exit
        });
    },

    _onError: function(err, msg) {
        if (this.options.logErrors) {
            console.warn(err, msg);
        }

        this.fire('error', {
            error: err,
            message: msg
        });
    },

    _removeUnknown: function(known) {
        var fId,
            removed = {};
        for (fId in this._featureLayers) {
            if (!known[fId]) {
                this._container.removeLayer(this._featureLayers[fId]);
                removed[fId] = this._features[fId];
                delete this._featureLayers[fId];
                delete this._features[fId];
            }
        }

        return removed;
    },

    _bustCache: function(url) {
        return url + L.Util.getParamString({'_': new Date().getTime()}, url);
    },

    _defaultSource: function(responseHandler, errorHandler) {
        var fetchOptions = this._fetchOptions,
            url = fetchOptions.url;
        
        url = this.options.cache ? url : this._bustCache(url);

        fetch(url, fetchOptions)
        .then(function(response) {
            return response.json();
        })
        .then(responseHandler)
        .catch(errorHandler);
    }
});

L.realtime = function(src, options) {
    return new L.Realtime(src, options);
};

module.exports = L.Realtime;

},{}]},{},[1])(1)
});
    </script>
    
    
    
    <script>
var map = L.map('map').setView([48.517,18.255], 5);

L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);

var shipLayer = L.layerGroup();
var ships = L.icon({
    iconUrl: 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Emoji_u1f6a2.svg/30px-Emoji_u1f6a2.svg.png',
    iconSize: [30, 30]
});

var realtime = L.realtime(
    /*
    I'm providing a function to simulate a GeoJSON service,
    instead of an URL
    
    {
    url: 'jsonServlet/ships.json',
    crossOrigin: true,
    type: 'json' 
    }*/
  function(success, error){
  	var ship = mockShip();
  	success(ship);
  }, {
    interval: 5 * 1000,
    getFeatureId: function(featureData){
    	return featureData.properties.mmsi;
    },
    pointToLayer: function (feature, latlng) {
      marker = L.marker(latlng, {icon: ships});
      marker.bindPopup('mmsi: ' + feature.properties.mmsi +
                       '<br/> course:' + feature.properties.hdg+
                       '<br/> speed:' + feature.properties.sog);
      marker.addTo(shipLayer);
      return marker;
    }
    
}).addTo(map);
//controlLayers.addOverlay(geojson, 'Ships');

realtime.on('update', function() {
    map.fitBounds(realtime.getBounds(), {maxZoom: 5});
});

function mockShip() {
  return {
    "type": "FeatureCollection",
    "crs": {
      "type": "name",
      "properties": {
        "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
      }
    },
    "features": [
      {
        "geometry": {
          "coordinates": [
            48.517+Math.sin((new Date).getTime())*2,
            18.255
          ],
          "type": "Point"
        },
        "type": "Feature",
        "properties": {
          "geometry/coordinates/longitude": "48.517708",
          "geometry/type": "Point",
          "mmsi": "512131345",
          "geometry/coordinates/latitude": "18.255447",
          "hdg": "108",
          "cog": "108",
          "sog": "30.0",
          "type": "Feature"
        }
      },
      {
        "geometry": {
          "coordinates": [
            48.415,
            18.151+Math.sin((new Date).getTime())*2
          ],
          "type": "Point"
        },
        "type": "Feature",
        "properties": {
          "geometry/coordinates/longitude": "48.417708",
          "geometry/type": "Point",
          "mmsi": "612131346",
          "geometry/coordinates/latitude": "18.155447",
          "hdg": "108",
          "cog": "108",
          "sog": "30.0",
          "type": "Feature"
        }
      }
    ]
  };
}
    </script>
    
</body>
</html>